// Generated by CoffeeScript 1.9.3
(function() {
  var async, autoable, clone, convert, defaults, merge, openLogFile, port, portscanner, ref, spawn, subprocess, verify;

  portscanner = require('portscanner');

  async = require('async');

  ref = require('lodash'), merge = ref.merge, clone = ref.clone;

  port = require('./port');

  openLogFile = require('./log');

  spawn = require('./spawn');

  verify = require('./verify');

  convert = function(proc) {
    var base;
    proc = merge({}, defaults(proc.name), proc);
    if ((base = proc.spawnOpts).cwd == null) {
      base.cwd = process.cwd();
    }
    return function(callback) {
      return openLogFile(proc.spawnOpts.cwd, proc.logFilePath, function(error, results) {
        var logHandle, logPath, spawnOpts;
        if (error != null) {
          return callback(error);
        }
        logHandle = results.fd, logPath = results.filename;
        spawnOpts = {
          stdio: ['ignore', logHandle, logHandle],
          env: clone(process.env)
        };
        merge(spawnOpts, proc.spawnOpts);
        return port.findOpen(proc.port, function(error, availablePort) {
          var child;
          if (error != null) {
            return callback(error);
          }
          child = spawn(proc.name, proc.command, proc.commandArgs, availablePort, logPath, logHandle, spawnOpts);
          return verify(child, proc.verify, proc.verifyInterval, proc.verifyTimeout, availablePort, function(error) {
            if (error != null) {
              return callback(error);
            }
            return callback(null, child);
          });
        });
      });
    };
  };

  autoable = function(name, proc) {
    var array, func, ref1;
    proc.name = name;
    func = convert(proc);
    if (((ref1 = proc.dependsOn) != null ? ref1.length : void 0) > 0) {
      array = clone(proc.dependsOn);
      array.push(func);
      return array;
    } else {
      return func;
    }
  };

  defaults = function(procName) {
    return {
      port: 0,
      logFilePath: "./log/" + procName + ".log",
      spawnOpts: {},
      verifyInterval: 100,
      verifyTimeout: 3000,
      verify: function(port, callback) {
        return portscanner.checkPortStatus(port, '127.0.0.1', function(error, status) {
          if (error != null) {
            return callback(error);
          }
          if (status === 'closed') {
            return callback(null, false);
          }
          return callback(null, true);
        });
      }
    };
  };

  subprocess = function(processConfig, callback) {
    var config, i, key, len, ref1;
    config = {};
    ref1 = Object.keys(processConfig);
    for (i = 0, len = ref1.length; i < len; i++) {
      key = ref1[i];
      config[key] = autoable(key, processConfig[key]);
    }
    return async.auto(config, function(error, procs) {
      if (error != null) {
        return callback(error);
      }
      return callback(null, procs);
    });
  };

  subprocess.killAll = function(procs) {
    var key, results1, value;
    results1 = [];
    for (key in procs) {
      value = procs[key];
      results1.push(value.rawProcess.kill());
    }
    return results1;
  };

  module.exports = subprocess;

}).call(this);
